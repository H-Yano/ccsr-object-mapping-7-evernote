<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>マッピング</title>
  <link th:replace="_fragments/head :: css-light">
</head>
<body>
<header>
  <nav>
    <a target="top" th:href="@{/}">トップに戻る</a>
    | <a target="application" th:href="@{/references/application}">アプリケーションの紹介</a>
    | <a target="_self" th:href="@{/references/object-mapping}">オブジェクトマッピングの概要</a>
    | <a target="architecture" th:href="@{/references/architecture}">技術方式と設計ガイドライン</a>
    | <a target="ccsr" th:href="@{/references/ccsr}">CCSR手法</a>
    | <a target="jig" th:href="@{/references/jig}">JIGドキュメント</a>
  </nav>
</header>

<h1>オブジェクトマッピングの概要</h1>
<p>
  ハーブ品種の品種番号と品種名を持つVarietyクラスのオブジェクトと、
  <strong>画面・テーブル・JSONデータ</strong>とのマッピングのやり方を説明します。
</p>
<pre>
  <code>
package example.domain.model.kit.row;

/**
* ハーブの品種を表現するクラス
*/
public class Variety {
    VarietyNumber varietyNumber;
    String name = "";

    public String show() {
        return String.format("%s [%s]", name, varietyNumber);
    }
}
  </code>
</pre>

<h2>マッピングする対象ごとの説明</h2>
<ul>
  <li>画面 ⇒ <a target="object-html" th:href="@{/references/object-html}">オブジェクト ⇔ HTMLのマッピング</a></li>
  <li>テーブル ⇒ <a target="object-sql" th:href="@{/references/object-sql}">オブジェクト ⇔ SQLのマッピング</a></li>
  <li>JSON ⇒ <a target="object-json" th:href="@{/references/object-json}">オブジェクト ⇔ JSONのマッピング</a></li>
</ul>
<h2>ドメインオブジェクトと外部のデータ形式のマッピング</h2>
<p>
  <img src="/diagram/mapping.jpg" width="640">
</p>
<h3>ドメインオブジェクト</h3>
<p>
  ドメインオブジェクトは、ドメインロジック（ビジネスロジック）の置き場所として設計します。<br />
  ビジネスルールに基づく計算・判断のロジックの置き場所です。<br />
  ドメインオブジェクトの設計には外部のデータ形式とのマッピングの関心事を持ち込むべきではありません。
</p>
<h3>オブジェクト内部のデータにアクセスする</h3>
<p>
  アプリケーションを実現するためには、ドメインオブジェクトと外部のデータ形式のマッピングが必要です。<br />
  計算・判断に使うデータを、ドメインオブジェクトの内部に設定する必要があります。<br />
  ドメインオブジェクトに内部にある、計算・判断の結果データを、外部に出力する必要があります。
</p>
<p>
  ドメインオブジェクトと外部データ形式のマッピングは、フレームワークを使って実現します。<br />
  このアプリケーションでは、画面(HTTPリクエストとレスポンス）とドメインオブジェクトのマッピングはSpring MVCを使っています。<br />
  データベーステーブル(SQL)とドメインオブジェクトのマッピングは、MyBatisを使っています。
</p>
<p>
  フレームワークを使ってドメインオブジェクトの内部にアクセスする方法は、３つあります。
</p>
<h4>フィールドをpublicにする</h4>
<p>
  最も単純な方法は、フィールドのアクセス修飾子を
</p>
<p>
  オブジェクトと外部データ形式のマッピングは、フレームワークによって簡単にできるようになりました。
  その反面、ドメインオブジェクトの設計が、フレームワーク側の要求や制約に歪められる危険があります。<br />
  ドメインオブジェクトの設計を、フレームワークの制約からできるだけ隔離すべきです。
</p>
<h2>フレームワークの要求・制約</h2>
<p>
  JavaBeans、プロパティの getter/setterメソッドを使う。
  この方法は、カプセル化違反であり、ビジネスロジックの置き場所として設計方針に反します。
</p>
<h2>ダイレクトフィールドアクセス</h2>
<p>
  どのマッピングも<strong>ダイレクトフィールドアクセス</strong>という方式を使っています。<br />
</p>
<p>
  Javaの伝統的な方法は、getter/setterメソッドを使ったフィールドアクセスです。<br />
  それに対し<strong>ダイレクトフィールドアクセス</strong>は、Javaのリフレクションを使って、
  マッピングのフレームワークがフィールドを直接参照する方式です。<br />
  publicでないフィールドも直接参照します。
</p>
<p>
  冗長なgetter/setterメソッドを書く必要がなく、ドメインオブジェクトのクラス定義を簡潔に保てます。
</p>
</body>
</html>